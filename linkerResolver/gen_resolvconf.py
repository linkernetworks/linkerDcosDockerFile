#!/usr/bin/python3.4

import os
import socket
import sys
import json
import codecs
import random
import urllib.request
from socket import inet_aton, error as socket_error
from subprocess import check_output, CalledProcessError

import dns.query


EXHIBITOR_STATUS_URL = 'http://{}:8181/exhibitor/v1/cluster/status'

if len(sys.argv) != 2:
    print('Usage: gen_resolvconf.py RESOLV_CONF_PATH', file=sys.stderr)
    print('Received: {}'.format(sys.argv), file=sys.stderr)
    sys.exit(-1)
resolvconf_path = sys.argv[1]
dns_test_query = 'master.mesos'
dns_timeout = 5


# TODO(cmaloney): Pull out into a utility library. Copied in both start_exhibitor.py
# and here.
def invoke_detect_ip():
    try:
        ip = check_output(
            ['/opt/mesosphere/bin/detect_ip']).strip().decode('utf-8')
    except CalledProcessError as e:
        print("check_output exited with {}".format(e))
        sys.exit(1)
    try:
        inet_aton(ip)
        return ip
    except socket_error as e:
        print(
            "inet_aton exited with {}. {} is not a valid IPv4 address".format(e, ip))
        sys.exit(1)


def get_masters_exhibitor():
    status_url = EXHIBITOR_STATUS_URL.format(os.environ['EXHIBITOR_ADDRESS'])
    try:
        servers = []
        response = urllib.request.urlopen(status_url)
        reader = codecs.getreader("utf-8")
        data = json.load(reader(response))
        for node in data:
            servers.append(socket.gethostbyname(node['hostname']))

        return servers
    except:
        print('Error getting list of masters from exhibitor {}: {}'.format(
            (status_url), sys.exc_info()[1]), file=sys.stderr)
        return []


def get_masters_file():
    return json.load(open('/opt/mesosphere/etc/master_list', 'r'))

def get_masters_env():
    try:
        servers = []
        masterszk = os.environ['MESOS_MASTER'].split('/')[2].split(',')
        for node in masterszk:
            servers.append(node.split(':')[0])
        return servers
    except:
        print('Error getting list of masters from environment {}: {}'.format(
            (MESOS_MASTER), sys.exc_info()[1]), file=sys.stderr)
        return []

def check_server(addr):
    try:
        query = dns.message.make_query(dns_test_query, dns.rdatatype.ANY)
        result = dns.query.udp(query, addr, dns_timeout)
        if len(result.answer) == 0:
            print('Skipping DNS server {}: no records for {}'.format(
                addr, dns_test_query), file=sys.stderr)
        else:
            return True
    except socket.gaierror as ex:
        print(ex, file=sys.stderr)
    except dns.exception.Timeout:
        print('Skipping DNS server {}: no response'.format(
            addr), file=sys.stderr)
    except:
        print("Unexpected error querying DNS for server \"{}\" exception: {}".format(
            addr, sys.exc_info()[1]))

    return False

mesos_dns_servers = []
master_source = os.environ['MASTER_SOURCE']
if master_source == 'exhibitor':
    mesos_dns_servers += get_masters_exhibitor()
elif master_source == 'master_list':
    mesos_dns_servers += get_masters_file()
elif master_source == 'env':
    mesos_dns_servers += get_masters_env()

# Test potential servers, throwing out unreachable ones.
up_master_nameservers = []
for addr in mesos_dns_servers:
    if check_server(addr):
        up_master_nameservers.append(addr)

# Fill up nameservers via the various sources until we hit MAXNS.
max_ns = 3
needed_server_count = 3
final_nameservers = []

# If try_localhost, always give that as first option
if os.environ.get('TRY_LOCALHOST', "false") == "true":
    ip = invoke_detect_ip()
    if check_server(ip):
        final_nameservers.append(ip)
        needed_server_count -= 1

    # Make sure we don't add the same IP twice
    if ip in up_master_nameservers:
        up_master_nameservers.remove(ip)

# Pick up to two servers at random, giving us a max three total servers per
# resolv.h MAXNS, with a good fallback dns server always present as the last in
# the set.
if len(up_master_nameservers) >= needed_server_count - 1:
    final_nameservers += random.sample(
        up_master_nameservers, needed_server_count - 1)
else:
    random.shuffle(up_master_nameservers)
    final_nameservers += up_master_nameservers

needed_server_count = max_ns - len(final_nameservers)

# Append fallback resolvers to fill out MAXNS
fallback_servers = os.environ['RESOLVERS'].split(',')
if len(fallback_servers) >= needed_server_count:
    final_nameservers += random.sample(fallback_servers, needed_server_count)
else:
    final_nameservers += fallback_servers

contents = """# Generated by gen_resolvconf.py. Do not edit.
# Change configuration options by changing DCOS cluster configuration.
# This file must be overwritten regularly for proper cluster operation around
# master failure.

options timeout:1
options attempts:3

"""

if 'SEARCH' in os.environ:
    contents += "search {}\n".format(os.environ['SEARCH'])

for ns in final_nameservers:
    contents += "nameserver {}\n".format(ns)

# Generate the resolv.conf config
print('Updating {}'.format(resolvconf_path))
with open(resolvconf_path, 'w') as f:
    print(contents, file=sys.stderr)
    f.write(contents)

sys.exit(0)

